"use strict";(self.webpackChunkfirehose=self.webpackChunkfirehose||[]).push([[149],{3905:function(e,t,r){r.d(t,{Zo:function(){return p},kt:function(){return f}});var n=r(7294);function o(e,t,r){return t in e?Object.defineProperty(e,t,{value:r,enumerable:!0,configurable:!0,writable:!0}):e[t]=r,e}function a(e,t){var r=Object.keys(e);if(Object.getOwnPropertySymbols){var n=Object.getOwnPropertySymbols(e);t&&(n=n.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),r.push.apply(r,n)}return r}function i(e){for(var t=1;t<arguments.length;t++){var r=null!=arguments[t]?arguments[t]:{};t%2?a(Object(r),!0).forEach((function(t){o(e,t,r[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(r)):a(Object(r)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(r,t))}))}return e}function s(e,t){if(null==e)return{};var r,n,o=function(e,t){if(null==e)return{};var r,n,o={},a=Object.keys(e);for(n=0;n<a.length;n++)r=a[n],t.indexOf(r)>=0||(o[r]=e[r]);return o}(e,t);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);for(n=0;n<a.length;n++)r=a[n],t.indexOf(r)>=0||Object.prototype.propertyIsEnumerable.call(e,r)&&(o[r]=e[r])}return o}var l=n.createContext({}),c=function(e){var t=n.useContext(l),r=t;return e&&(r="function"==typeof e?e(t):i(i({},t),e)),r},p=function(e){var t=c(e.components);return n.createElement(l.Provider,{value:t},e.children)},u={inlineCode:"code",wrapper:function(e){var t=e.children;return n.createElement(n.Fragment,{},t)}},d=n.forwardRef((function(e,t){var r=e.components,o=e.mdxType,a=e.originalType,l=e.parentName,p=s(e,["components","mdxType","originalType","parentName"]),d=c(r),f=o,h=d["".concat(l,".").concat(f)]||d[f]||u[f]||a;return r?n.createElement(h,i(i({ref:t},p),{},{components:r})):n.createElement(h,i({ref:t},p))}));function f(e,t){var r=arguments,o=t&&t.mdxType;if("string"==typeof e||o){var a=r.length,i=new Array(a);i[0]=d;var s={};for(var l in t)hasOwnProperty.call(t,l)&&(s[l]=t[l]);s.originalType=e,s.mdxType="string"==typeof e?e:o,i[1]=s;for(var c=2;c<a;c++)i[c]=r[c];return n.createElement.apply(null,i)}return n.createElement.apply(null,r)}d.displayName="MDXCreateElement"},8225:function(e,t,r){r.r(t),r.d(t,{assets:function(){return p},contentTitle:function(){return l},default:function(){return f},frontMatter:function(){return s},metadata:function(){return c},toc:function(){return u}});var n=r(7462),o=r(3366),a=(r(7294),r(3905)),i=["components"],s={},l="Decorators",c={unversionedId:"concepts/decorators",id:"concepts/decorators",title:"Decorators",description:"Decorators implement the Sink interface, and they can wrap other sinks. Decorators can also wrap other decorators. They",source:"@site/docs/concepts/decorators.md",sourceDirName:"concepts",slug:"/concepts/decorators",permalink:"/firehose/concepts/decorators",draft:!1,editUrl:"https://github.com/odpf/firehose/edit/master/docs/docs/concepts/decorators.md",tags:[],version:"current",frontMatter:{},sidebar:"docsSidebar",previous:{title:"Firehose Consumer",permalink:"/firehose/concepts/consumer"},next:{title:"Offset manager",permalink:"/firehose/concepts/offsets"}},p={},u=[{value:"Type of Decorators",id:"type-of-decorators",level:2},{value:"SinkWithFailHandler",id:"sinkwithfailhandler",level:3},{value:"SinkWithRetry",id:"sinkwithretry",level:3},{value:"SinkWithDlq",id:"sinkwithdlq",level:3},{value:"Log",id:"log",level:4},{value:"Kafka",id:"kafka",level:4},{value:"Blob",id:"blob",level:4},{value:"SinkFinal",id:"sinkfinal",level:3}],d={toc:u};function f(e){var t=e.components,r=(0,o.Z)(e,i);return(0,a.kt)("wrapper",(0,n.Z)({},d,r,{components:t,mdxType:"MDXLayout"}),(0,a.kt)("h1",{id:"decorators"},"Decorators"),(0,a.kt)("p",null,"Decorators implement the Sink interface, and they can wrap other sinks. Decorators can also wrap other decorators. They\nprocess messages returned by the wrapped Sink. Sink and SinkDecorator pushMessage() API return messages that were not\nsuccessful."),(0,a.kt)("h2",{id:"type-of-decorators"},"Type of Decorators"),(0,a.kt)("p",null,"This is the order of execution decorators after sink returns failed messages.\nA failed message will have one of these error types:"),(0,a.kt)("ul",null,(0,a.kt)("li",{parentName:"ul"},"DESERIALIZATION_ERROR"),(0,a.kt)("li",{parentName:"ul"},"INVALID_MESSAGE_ERROR"),(0,a.kt)("li",{parentName:"ul"},"UNKNOWN_FIELDS_ERROR"),(0,a.kt)("li",{parentName:"ul"},"SINK_4XX_ERROR"),(0,a.kt)("li",{parentName:"ul"},"SINK_5XX_ERROR"),(0,a.kt)("li",{parentName:"ul"},"SINK_UNKNOWN_ERROR"),(0,a.kt)("li",{parentName:"ul"},"DEFAULT_ERROR")),(0,a.kt)("h3",{id:"sinkwithfailhandler"},"SinkWithFailHandler"),(0,a.kt)("p",null,"This decorator is intended to be used to trigger consumer failure based on configured error types.\nConfiguration ",(0,a.kt)("inlineCode",{parentName:"p"},"ERROR_TYPES_FOR_FAILING")," is to be set with the comma separated list of Error types."),(0,a.kt)("h3",{id:"sinkwithretry"},"SinkWithRetry"),(0,a.kt)("p",null,"This decorator retries to push messages based on the configuration set for error types ",(0,a.kt)("inlineCode",{parentName:"p"},"ERROR_TYPES_FOR_RETRY"),".\nIt will retry for the maximum of ",(0,a.kt)("inlineCode",{parentName:"p"},"RETRY_MAX_ATTEMPTS")," with exponential back off."),(0,a.kt)("h3",{id:"sinkwithdlq"},"SinkWithDlq"),(0,a.kt)("p",null,"This decorator pushes messages to DLQ based on the error types set in ",(0,a.kt)("inlineCode",{parentName:"p"},"ERROR_TYPES_FOR_DLQ"),".\nThis decorator will only be added if ",(0,a.kt)("inlineCode",{parentName:"p"},"DLQ_SINK_ENABLE")," is set to be true.\nThere are three types of DLQWriter that can be configured by setting ",(0,a.kt)("inlineCode",{parentName:"p"},"DLQ_WRITER_TYPE"),"."),(0,a.kt)("h4",{id:"log"},"Log"),(0,a.kt)("p",null,"This is just for debugging, it prints out the messages to standard output."),(0,a.kt)("h4",{id:"kafka"},"Kafka"),(0,a.kt)("p",null,"Based on the configurations in ",(0,a.kt)("inlineCode",{parentName:"p"},"DlqKafkaProducerConfig")," class, messages are pushed to kafka."),(0,a.kt)("h4",{id:"blob"},"Blob"),(0,a.kt)("p",null,"Blob Storage can also be used to DLQ messages. Currently, only GCS is supported as a store.\nThe ",(0,a.kt)("inlineCode",{parentName:"p"},"BlobStorageDlqWriter")," converts each message into json String, and appends multiple messages via new line.\nThese messages are pushed to a blob storage. The object name for messages is",(0,a.kt)("inlineCode",{parentName:"p"},"topic_name/consumed_timestamp/a-random-uuid"),"."),(0,a.kt)("h3",{id:"sinkfinal"},"SinkFinal"),(0,a.kt)("p",null,"This decorator is the black hole for messages. The messages reached here are ignored\nand no more processing is done on them."))}f.isMDXComponent=!0}}]);