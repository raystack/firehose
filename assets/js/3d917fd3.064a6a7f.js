"use strict";(self.webpackChunkfirehose=self.webpackChunkfirehose||[]).push([[453],{3905:function(e,n,t){t.d(n,{Zo:function(){return u},kt:function(){return m}});var a=t(7294);function r(e,n,t){return n in e?Object.defineProperty(e,n,{value:t,enumerable:!0,configurable:!0,writable:!0}):e[n]=t,e}function i(e,n){var t=Object.keys(e);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);n&&(a=a.filter((function(n){return Object.getOwnPropertyDescriptor(e,n).enumerable}))),t.push.apply(t,a)}return t}function l(e){for(var n=1;n<arguments.length;n++){var t=null!=arguments[n]?arguments[n]:{};n%2?i(Object(t),!0).forEach((function(n){r(e,n,t[n])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(t)):i(Object(t)).forEach((function(n){Object.defineProperty(e,n,Object.getOwnPropertyDescriptor(t,n))}))}return e}function o(e,n){if(null==e)return{};var t,a,r=function(e,n){if(null==e)return{};var t,a,r={},i=Object.keys(e);for(a=0;a<i.length;a++)t=i[a],n.indexOf(t)>=0||(r[t]=e[t]);return r}(e,n);if(Object.getOwnPropertySymbols){var i=Object.getOwnPropertySymbols(e);for(a=0;a<i.length;a++)t=i[a],n.indexOf(t)>=0||Object.prototype.propertyIsEnumerable.call(e,t)&&(r[t]=e[t])}return r}var s=a.createContext({}),p=function(e){var n=a.useContext(s),t=n;return e&&(t="function"==typeof e?e(n):l(l({},n),e)),t},u=function(e){var n=p(e.components);return a.createElement(s.Provider,{value:n},e.children)},d={inlineCode:"code",wrapper:function(e){var n=e.children;return a.createElement(a.Fragment,{},n)}},c=a.forwardRef((function(e,n){var t=e.components,r=e.mdxType,i=e.originalType,s=e.parentName,u=o(e,["components","mdxType","originalType","parentName"]),c=p(t),m=r,f=c["".concat(s,".").concat(m)]||c[m]||d[m]||i;return t?a.createElement(f,l(l({ref:n},u),{},{components:t})):a.createElement(f,l({ref:n},u))}));function m(e,n){var t=arguments,r=n&&n.mdxType;if("string"==typeof e||r){var i=t.length,l=new Array(i);l[0]=c;var o={};for(var s in n)hasOwnProperty.call(n,s)&&(o[s]=n[s]);o.originalType=e,o.mdxType="string"==typeof e?e:r,l[1]=o;for(var p=2;p<i;p++)l[p]=t[p];return a.createElement.apply(null,l)}return a.createElement.apply(null,t)}c.displayName="MDXCreateElement"},4944:function(e,n,t){t.r(n),t.d(n,{assets:function(){return u},contentTitle:function(){return s},default:function(){return m},frontMatter:function(){return o},metadata:function(){return p},toc:function(){return d}});var a=t(7462),r=t(3366),i=(t(7294),t(3905)),l=["components"],o={},s="JSON-based Filters",p={unversionedId:"guides/json-based-filters",id:"guides/json-based-filters",title:"JSON-based Filters",description:"To enable JSON-based filtering, you will need to set the Firehose environment variable asFILTERENGINE=JSON and provide the required JSON Schema filter string to the variableFILTERJSON_SCHEMA. JSON-based filters can be applied to both JSON as well as Protobuf messages.",source:"@site/docs/guides/json-based-filters.md",sourceDirName:"guides",slug:"/guides/json-based-filters",permalink:"/firehose/guides/json-based-filters",draft:!1,editUrl:"https://github.com/odpf/firehose/edit/master/docs/docs/guides/json-based-filters.md",tags:[],version:"current",frontMatter:{},sidebar:"docsSidebar",previous:{title:"Creating Firehose",permalink:"/firehose/guides/create_firehose"},next:{title:"JEXL-based Filters",permalink:"/firehose/guides/jexl-based-filters"}},u={},d=[{value:"JSON Schema Features",id:"json-schema-features",level:2},{value:"Checking equality",id:"checking-equality",level:3},{value:"String",id:"string",level:4},{value:"Integer",id:"integer",level:4},{value:"Float",id:"float",level:4},{value:"Boolean",id:"boolean",level:4},{value:"Array",id:"array",level:4},{value:"Enumerated values",id:"enumerated-values",level:3},{value:"Numeric <strong>Range</strong>",id:"numeric-range",level:3},{value:"Regex Match",id:"regex-match",level:3},{value:"Conditional operators",id:"conditional-operators",level:3},{value:"Logical operators",id:"logical-operators",level:3},{value:"allOf",id:"allof",level:4},{value:"anyOf",id:"anyof",level:4},{value:"oneOf",id:"oneof",level:4},{value:"not",id:"not",level:4},{value:"Nested fields",id:"nested-fields",level:3}],c={toc:d};function m(e){var n=e.components,t=(0,r.Z)(e,l);return(0,i.kt)("wrapper",(0,a.Z)({},c,t,{components:n,mdxType:"MDXLayout"}),(0,i.kt)("h1",{id:"json-based-filters"},"JSON-based Filters"),(0,i.kt)("p",null,"To enable JSON-based filtering, you will need to set the Firehose environment variable as",(0,i.kt)("inlineCode",{parentName:"p"},"FILTER_ENGINE=JSON")," and provide the required JSON Schema filter string to the variable",(0,i.kt)("inlineCode",{parentName:"p"},"FILTER_JSON_SCHEMA"),". JSON-based filters can be applied to both JSON as well as Protobuf messages. "),(0,i.kt)("p",null,"This article enlists only a few common features of JSON Schema. For more details on other features, refer the ",(0,i.kt)("a",{parentName:"p",href:"https://json-schema.org/specification.html"},"JSON Schema specifications"),". For more examples on JSON Schema, refer ",(0,i.kt)("a",{parentName:"p",href:"https://json-schema.org/learn/miscellaneous-examples.html"},"this article"),"."),(0,i.kt)("h2",{id:"json-schema-features"},"JSON Schema Features"),(0,i.kt)("h3",{id:"checking-equality"},"Checking equality"),(0,i.kt)("p",null,"The ",(0,i.kt)("inlineCode",{parentName:"p"},"const")," keyword is used to restrict a value to a single value. "),(0,i.kt)("h4",{id:"string"},"String"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-text"},'{\n  "properties": {\n    "country": {\n      "const": "United States of America"\n    }\n  }\n}\n\n/* valid */\n{ "country": "United States of America" }\n\n/* invalid */\n{ "country": "Canada" }\n')),(0,i.kt)("h4",{id:"integer"},"Integer"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-text"},'{\n  "properties": {\n    "age": {\n      "const": 23\n    }\n  }\n}\n\n/* valid */\n{ "age": 23 }\n\n/* invalid */\n{ "age": "23" }\n{ "age": 29 }\n')),(0,i.kt)("h4",{id:"float"},"Float"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-text"},'{\n  "properties": {\n    "price": {\n      "const": 932.4556\n    }\n  }\n}\n\n/* valid */\n{ "price": 932.4556 }\n\n/* invalid */\n{ "price": "932.4556" }\n{ "price": 932.455 }\n')),(0,i.kt)("h4",{id:"boolean"},"Boolean"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-text"},'{\n  "properties": {\n    "auth_enabled": {\n      "const": true\n    }\n  }\n}\n\n/* valid */\n{ "auth_enabled": true }\n\n/* invalid */\n{ "auth_enabled": "true" }\n{ "auth_enabled": false }\n')),(0,i.kt)("h4",{id:"array"},"Array"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-text"},'{\n  "properties": {\n    "roll_nos": {\n      "const": [5,23,7]\n    }\n  }\n}\n\n/* valid */\n{ "roll_nos": [5,23,7] }\n\n/* invalid */\n{ "roll_nos": [23,2,7] }\n')),(0,i.kt)("h3",{id:"enumerated-values"},"Enumerated values"),(0,i.kt)("p",null,"The ",(0,i.kt)("inlineCode",{parentName:"p"},"enum")," keyword is used to restrict a value to a fixed set of values. It must be an array with at least one element, where each element is unique."),(0,i.kt)("p",null,"The following is an example for validating street light colors:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-text"},'{\n   "properties":{\n      "color":{\n         "enum":[ "red","amber", "green" ]\n      }\n   }\n}\n\n/* valid */\n{"color":"red"}\n\n/* invalid */\n{"color":"blue"}\n')),(0,i.kt)("h3",{id:"numeric-range"},"Numeric ",(0,i.kt)("strong",{parentName:"h3"},"Range")),(0,i.kt)("p",null,"Ranges of numbers are specified using a combination of the ",(0,i.kt)("inlineCode",{parentName:"p"},"minimum")," and ",(0,i.kt)("inlineCode",{parentName:"p"},"maximum")," keywords, ","(","or ",(0,i.kt)("inlineCode",{parentName:"p"},"exclusiveMinimum")," and ",(0,i.kt)("inlineCode",{parentName:"p"},"exclusiveMaximum")," for expressing exclusive range",")","."),(0,i.kt)("p",null,"If x is the value being validated, the following must hold true:",(0,i.kt)("br",{parentName:"p"}),"\n","x \u2265 ",(0,i.kt)("inlineCode",{parentName:"p"},"minimum"),(0,i.kt)("br",{parentName:"p"}),"\n","x ",">"," ",(0,i.kt)("inlineCode",{parentName:"p"},"exclusiveMinimum"),(0,i.kt)("br",{parentName:"p"}),"\n","x \u2264 ",(0,i.kt)("inlineCode",{parentName:"p"},"maximum"),(0,i.kt)("br",{parentName:"p"}),"\n","x ","<"," ",(0,i.kt)("inlineCode",{parentName:"p"},"exclusiveMaximum")),(0,i.kt)("p",null,"Example:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-text"},'{\n   "properties":{\n      "age":{\n         "minimum":0,\n         "maximum":100\n      }\n   }\n}\n\n\n/* valid */\n{"age":0}\n{"age":100}\n{"age":99}\n\n\n/* invalid */\n{"age":-1}\n{"age":101}\n')),(0,i.kt)("h3",{id:"regex-match"},"Regex Match"),(0,i.kt)("p",null,"The ",(0,i.kt)("inlineCode",{parentName:"p"},"pattern")," keyword is used to restrict a string to a particular regular expression. The regular expression syntax is the one defined in JavaScript ","(","ECMA 262 specifically",")",". See Regular Expressions for more information."),(0,i.kt)("p",null,"Example:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-text"},'{\n   "properties":{\n      "pincode":{\n         "pattern":"^(\\\\([0-9]{3}\\\\))?[0-9]{3}-[0-9]{4}$"\n      }\n   }\n}\n\n// valid\n{ "pincode": "555-1212" }\n{ "pincode": "(888)555-1212" }\n\n// invalid\n{ "pincode": "(888)555-1212 ext. 532" }\n{ "pincode": "(800)FLOWERS" }\n')),(0,i.kt)("h3",{id:"conditional-operators"},"Conditional operators"),(0,i.kt)("p",null,"The ",(0,i.kt)("strong",{parentName:"p"},(0,i.kt)("inlineCode",{parentName:"strong"},"if"),", ",(0,i.kt)("inlineCode",{parentName:"strong"},"then")," and ",(0,i.kt)("inlineCode",{parentName:"strong"},"else"))," keywords allow the application of a sub-schema based on the outcome of another schema, much like the if/then/else constructs you\u2019ve probably seen in traditional programming languages. If if is valid, then must also be valid ","(","and else is ignored.",")"," If if is invalid, else must also be valid ","(","and then is ignored",")","."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-text"},'{\n  "if": {\n    "properties": { "country": { "const": "United States of America" } }\n  },\n  "then": {\n    "properties": { "postal_code": { "pattern": "[0-9]{5}(-[0-9]{4})?" } }\n  },\n  "else": {\n    "properties": { "postal_code": { "pattern": "[A-Z][0-9][A-Z] [0-9][A-Z][0-9]" } }\n  }\n}\n\n/* valid */\n{\n  "street_address": "1600 Pennsylvania Avenue NW",\n  "country": "United States of America",\n  "postal_code": "20500"\n}\n\n{\n  "street_address": "24 Sussex Drive",\n  "country": "Canada",\n  "postal_code": "K1M 1M4"\n}\n\n/* invalid */\n{\n  "street_address": "24 Sussex Drive",\n  "country": "Canada",\n  "postal_code": "10000"\n}\n')),(0,i.kt)("h3",{id:"logical-operators"},"Logical operators"),(0,i.kt)("p",null,"The keywords used to combine schemas are:"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"allOf"),": Must be valid against all of the sub-schemas"),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"oneOf"),": Must be valid against exactly one of the sub-schemas"),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"anyOf"),": Must be valid against any of the sub-schemas")),(0,i.kt)("h4",{id:"allof"},"allOf"),(0,i.kt)("p",null,"To validate against ",(0,i.kt)("inlineCode",{parentName:"p"},"allOf"),", the given data must be valid against all of the given sub-schemas."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-text"},'{\n   "properties":{\n      "age":{\n         "allOf":[\n            { "multipleOf":5 },\n            { "multipleOf":3 }\n         ]\n      }\n   }\n}\n\n/* valid */\n{"age:15}\n{"age:30}\n\n\n/* invalid */\n{"age:5}\n{"age:9}\n')),(0,i.kt)("h4",{id:"anyof"},"anyOf"),(0,i.kt)("p",null,"To validate against ",(0,i.kt)("inlineCode",{parentName:"p"},"anyOf"),", the given data must be valid against any ","(","one or more",")"," of the given sub-schemas."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-text"},'{\n   "properties":{\n      "age":{\n         "anyOf":[\n            { "multipleOf":5 },\n            { "multipleOf":3 }\n         ]\n      }\n   }\n}\n\n/* valid */\n{"age:10}\n{"age:15}\n\n\n/* invalid */\n{"age:2}\n{"age:7}\n')),(0,i.kt)("h4",{id:"oneof"},"oneOf"),(0,i.kt)("p",null,"To validate against ",(0,i.kt)("inlineCode",{parentName:"p"},"oneOf"),", the given data must be valid against exactly one of the given sub-schemas."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-text"},'{\n   "properties":{\n      "age":{\n         "oneOf":[\n            { "multipleOf":5 },\n            { "multipleOf":3 }\n         ]\n      }\n   }\n}\n\n/* valid */\n{"age:10}\n{"age:9}\n\n\n/* invalid */\n{"age:2}\n{"age:15}\n')),(0,i.kt)("h4",{id:"not"},"not"),(0,i.kt)("p",null,"The ",(0,i.kt)("inlineCode",{parentName:"p"},"not")," keyword declares that a instance validates if it doesn\u2019t validate against the given sub-schema."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-text"},'{\n   "properties":{\n      "fruit":{\n         "not":{\n            "const":"apple"\n         }\n      }\n   }\n}\n\n/* valid */\n{"fruit":"mango"}\n{"fruit":"errr"}\n\n/* invalid */\n{"fruit":"apple"}\n')),(0,i.kt)("h3",{id:"nested-fields"},"Nested fields"),(0,i.kt)("p",null,"You can apply all the above validation features to any level of nested fields in the JSON/ Protobuf message. Consider the below example - "),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-text"},'{\n   "properties":{\n      "driver_location":{\n         "properties":{\n            "latitude":{\n               "minimum":-90.453,\n               "maximum":90.2167\n            },\n            "longitude":{\n               "minimum":-180.776,\n               "maximum":180.321\n            }\n         }\n      }\n   }\n}\n')))}m.isMDXComponent=!0}}]);